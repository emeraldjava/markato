// Generated by CoffeeScript 1.10.0
(function() {
  var addLyricChord, addSection, isChordLine, markatoObjectFromState, parseLine, preParseFooterLine, preParseFooterStartLine, preParseLine, preParseMetaLine, preParseTextLine;

  isChordLine = function(line) {
    return S(line).startsWith(':');
  };

  preParseFooterStartLine = function(state, line) {
    state.current.footer = true;
    return state;
  };

  preParseMetaLine = function(state, line) {
    var metaName, metaValue, prefix;
    prefix = line.split(' ')[0];
    metaName = prefix.slice(2);
    metaValue = S(line).chompLeft(prefix).trim().s;
    state.meta[metaName] = metaValue;
    return state;
  };

  preParseFooterLine = function(state, line) {
    var alts, chord, parts;
    parts = S(line).strip(' ').split('=>');
    if (parts.length === 2) {
      chord = parts[0];
      alts = parts[1].split(',');
      state.alts[chord] = alts;
    }
    return state;
  };

  preParseTextLine = function(state, line) {
    var lastLine;
    if (state.lines.length) {
      lastLine = _.last(state.lines);
    }
    if (S(line).startsWith('#')) {
      state.lines.push({
        type: 'section',
        name: S(line.slice(1)).trim().s
      });
    } else if (isChordLine(line)) {
      state.lines.push({
        type: 'lyricChord',
        chords: S(line.slice(1)).trim().s.split(' '),
        lyrics: ''
      });
    } else {
      if (lastLine && lastLine.type === 'lyricChord' && !lastLine.lyrics) {
        lastLine.lyrics = line;
      } else {
        state.lines.push({
          type: 'lyricChord',
          chords: [],
          lyrics: line
        });
      }
    }
    return state;
  };

  preParseLine = function(state, line) {
    line = S(line).trim().collapseWhitespace().s;
    if (!line) {
      return state;
    }
    if (S(line).startsWith('###')) {
      return preParseFooterStartLine(state, line);
    }
    if (S(line).startsWith('##')) {
      return preParseMetaLine(state, line);
    }
    if (state.current.footer) {
      return preParseFooterLine(state, line);
    }
    return preParseTextLine(state, line);
  };

  addSection = function(state, sectionName) {
    state.current.sectionName = sectionName;
    state.current.newSection = !_.contains(state.sections, sectionName);
    state.current.line = 0;
    state.sections.push(sectionName);
    state.lyrics.push({
      section: sectionName,
      firstTime: state.current.newSection,
      lines: []
    });
    if (state.current.newSection) {
      state.chords[sectionName] = [];
    }
    return state;
  };

  addLyricChord = function(state, lyrics, chords) {
    var addPhrase, caratSplit, chordIndex, exceptionIndices, phrases, sectionChords, sectionName;
    sectionName = state.current.sectionName;
    caratSplit = lyrics.split('^');
    chordIndex = 0;
    phrases = [];
    exceptionIndices = [];
    addPhrase = function(obj) {
      return phrases.push(_.defaults(obj, {
        string: '',
        chord: '',
        exception: false,
        wordExtension: false
      }));
    };
    if (sectionName === null) {
      sectionName = 'UNTITLED';
      state = addSection(state, sectionName);
    }
    if (state.current.newSection) {
      state.chords[sectionName].push(chords);
    }
    sectionChords = state.chords[sectionName][state.current.line];
    if (!chords.length) {
      chords = sectionChords;
    } else {
      chords = _.map(chords, function(chord, index) {
        if (chord === '*') {
          return sectionChords[index];
        } else {
          exceptionIndices.push(index);
          return chord;
        }
      });
    }
    if (!lyrics) {
      _.each(chords, function(chord, index) {
        return addPhrase({
          chord: chord,
          exception: _.contains(exceptionIndices, index)
        });
      });
    } else {
      _.each(caratSplit, function(phrase, index) {
        var chord, lastPhrase;
        if (index === 0) {
          if (phrase) {
            addPhrase({
              string: caratSplit[0]
            });
          }
          return;
        }
        lastPhrase = caratSplit[index - 1];
        chord = chords[chordIndex];
        if ((phrase != null) && phrase[0] === ' ') {
          addPhrase({
            chord: chord,
            exception: _.contains(exceptionIndices, chordIndex)
          });
          addPhrase({
            string: S(phrase).trim().s
          });
        } else {
          addPhrase({
            string: S(phrase).trim().s,
            chord: chord,
            exception: _.contains(exceptionIndices, chordIndex)
          });
        }
        if (phrase && lastPhrase && phrase[0] !== ' ' && S(lastPhrase).right(1).s !== ' ') {
          _.last(phrases).wordExtension = true;
        }
        return chordIndex += 1;
      });
    }
    _.last(state.lyrics).lines.push(phrases);
    state.current.line += 1;
    return state;
  };

  parseLine = function(state, line) {
    if (line.type === 'section') {
      return addSection(state, line.name);
    }
    if (line.type === 'lyricChord') {
      return addLyricChord(state, line.lyrics, line.chords);
    }
    return state;
  };

  markatoObjectFromState = function(state) {
    return _.omit(state, 'current');
  };

  window.parser = {
    parseString: function(str) {
      var lines, parseState, preParseState;
      lines = S(str).lines();
      preParseState = {
        current: {
          footer: false
        },
        meta: {},
        alts: {},
        lines: []
      };
      parseState = {
        current: {
          sectionName: null,
          newSection: true,
          line: 0
        },
        sections: [],
        chords: {},
        lyrics: []
      };
      preParseState = _.reduce(lines, preParseLine, preParseState);
      parseState.meta = preParseState.meta;
      parseState.alts = preParseState.alts;
      parseState = _.reduce(preParseState.lines, parseLine, parseState);
      return markatoObjectFromState(parseState);
    }
  };

}).call(this);
